var documenterSearchIndex = {"docs":
[{"location":"functions/#Main-functions","page":"Main functions","title":"Main functions","text":"","category":"section"},{"location":"functions/#Motion-correction","page":"Main functions","title":"Motion correction","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"motion_corrected_reconstruction(F::RetrospectiveMotionCorrectionMRI.StructuredNFFTtype2LinOp{T}, d::AbstractArray{CT,2}, u::AbstractArray{CT,3}, θ::AbstractArray{T,2}, options::RetrospectiveMotionCorrectionMRI.MotionCorrectionOptionsAlternatingFISTADiff) where {T<:Real,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.motion_corrected_reconstruction-Union{Tuple{CT}, Tuple{T}, Tuple{StructuredNFFTtype2LinOp{T}, AbstractMatrix{CT}, AbstractArray{CT, 3}, AbstractMatrix{T}, RetrospectiveMotionCorrectionMRI.MotionCorrectionOptionsAlternatingFISTADiff}} where {T<:Real, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.motion_corrected_reconstruction","text":"motion_corrected_reconstruction(F, d, u, θ, options)\n\nPerforms retrospective motion correction of some data d. F is the Fourier operator, initialized via the package UtilitiesForMRI. The initial estimates for image and motion parameters are u and θ. The minimization options are passed via the routine motion_correction_options.\n\nSee this section for more details on the solution algorithm.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"motion_correction_options(; image_reconstruction_options::ImageReconstructionOptionsFISTA, parameter_estimation_options::ParameterEstimationOptionsDiff, niter::Integer, niter_estimate_Lipschitz::Union{Nothing,Integer}=nothing, verbose::Bool=false, fun_history::Bool=false)","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.motion_correction_options-Tuple{}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.motion_correction_options","text":"motion_correction_options(; image_reconstruction_options,\n                            parameter_estimation_options,\n                            niter,\n                            verbose, fun_history)\n\nReturn motion correction options for alternating rigid motion estimation and image reconstruction:\n\nimage_reconstruction_options: set via the corresponding option routine\nparameter_estimation_options: set via the corresponding option routine\nniter: number of outer two-step loops\nverbose, fun_history: for debugging purposes\n\nNote: for more details consult this section.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Image-reconstruction","page":"Main functions","title":"Image reconstruction","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"image_reconstruction(F::AbstractLinearOperator{CT,3,2}, d::AbstractArray{CT,2}, initial_estimate::AbstractArray{CT,3}, options::RetrospectiveMotionCorrectionMRI.ImageReconstructionOptionsFISTA) where {T<:Real,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.image_reconstruction-Union{Tuple{CT}, Tuple{T}, Tuple{AbstractLinearOperator{CT, 3, 2}, AbstractMatrix{CT}, AbstractArray{CT, 3}, RetrospectiveMotionCorrectionMRI.ImageReconstructionOptionsFISTA}} where {T<:Real, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.image_reconstruction","text":"image_reconstruction(F, d, initial_estimate, options)\n\nPerforms image reconstruction by fitting the data d through a linear operator F (e.g. the Fourier transform). initial_estimate sets the initial guess. The minimization options are passed via the routine image_reconstruction_options.\n\nSee this section for more details on the solution algorithm.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"image_reconstruction_options(; prox::AbstractProximableFunction,\n                               Lipschitz_constant::Union{Nothing,Real}=nothing,\n                               Nesterov::Bool=true,\n                               reset_counter::Union{Nothing,Integer}=nothing,\n                               niter::Union{Nothing,Integer}=nothing,\n                               verbose::Bool=false,\n                               fun_history::Bool=false)","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.image_reconstruction_options-Tuple{}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.image_reconstruction_options","text":"image_reconstruction_options(; prox::AbstractProximableFunction,\n                               Lipschitz_constant=nothing,\n                               niter_estimate_Lipschitz=nothing\n                               Nesterov=true,\n                               reset_counter=nothing,\n                               niter=nothing,\n                               verbose=false,\n                               fun_history=false)\n\nReturns image reconstruction options for the routine image_reconstruction:\n\nprox: regularization function (for which a proximal operator is implemented)\nLipschitz_constant: Lipschitz constant of a smooth objective\nniter_estimate_Lipschitz: when set to an Integer, the iterative power method is invoked in order to estimate the Lipschitz constant with the specified number of iteration\nNesterov: allows Nesterov acceleration (default)\nreset_counter: number of iterations after which the Nesterov acceleration is reset\nniter: number of iterations\nverbose, fun_history: for debugging purposes\n\nNote: for more details on each of these parameters, consult this section.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Rigid-motion-parameter-estimation","page":"Main functions","title":"Rigid motion parameter estimation","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"parameter_estimation(F::RetrospectiveMotionCorrectionMRI.StructuredNFFTtype2LinOp{T}, u::AbstractArray{CT,3}, d::AbstractArray{CT,2}, initial_estimate::AbstractArray{T}, options::RetrospectiveMotionCorrectionMRI.ParameterEstimationOptionsDiff) where {T<:Real,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.parameter_estimation-Union{Tuple{CT}, Tuple{T}, Tuple{StructuredNFFTtype2LinOp{T}, AbstractArray{CT, 3}, AbstractMatrix{CT}, AbstractArray{T}, RetrospectiveMotionCorrectionMRI.ParameterEstimationOptionsDiff}} where {T<:Real, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.parameter_estimation","text":"parameter_estimation(F, u, d, initial_estimate::AbstractArray{T}, options)\n\nSolves the rigid-motion parameter estimation optimization problem described here. F is a Fourier linear operator, initialized with the package UtilitiesForMRI (see Section Getting started for some examples on how to do it). u is a fixed known image, d given data, and initial_estimate a starting guess for the rigid motion parameters.\n\nFor optimization options, refer to parameter_estimation_options.\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"parameter_estimation_options(; niter::Integer=10,\n                                        steplength::Real=1f0,\n                                        λ::Real=0f0,\n                                        scaling_diagonal::Real=0f0, scaling_mean::Real=0f0, scaling_id::Real=0f0,\n                                        reg_matrix::Union{Nothing,AbstractMatrix{<:Real}}=nothing,\n                                        interp_matrix::Union{Nothing,AbstractMatrix{<:Real}}=nothing,\n                                        calibration::Bool=false,\n                                        verbose::Bool=false,\n                                        fun_history::Bool=false)","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.parameter_estimation_options-Tuple{}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.parameter_estimation_options","text":"parameter_estimation_options(; niter=10,\n                               steplength=1f0,\n                               λ=0f0,\n                               scaling_diagonal=0f0, scaling_mean=0f0, scaling_id=0f0,\n                               reg_matrix=nothing,\n                               interp_matrix=nothing,\n                               verbose=false,\n                               fun_history=false)\n\nReturns parameter estimation options for the optimization problem underlying the solver parameter_estimation:\n\nniter: number of iterations\nsteplength\nλ: weight of regularization\nscaling_diagonal, scaling_mean, scaling_id: parameters associated to the pseudo-Hessian of the objective\nreg_matrix: regularization weight matrix\ninterp_matrix: interpolation matrix\nverbose, fun_history: for debugging purposes\n\nNote: for more details on each of these parameters, consult this section.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Rigid-registration-utilities","page":"Main functions","title":"Rigid registration utilities","text":"","category":"section"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"rigid_registration(u_moving::AbstractArray{CT,3}, u_fixed::AbstractArray{CT,3}, θ::Union{Nothing,AbstractArray{T}}, options::RetrospectiveMotionCorrectionMRI.ParameterEstimationOptionsDiff; spatial_geometry::Union{Nothing,CartesianSpatialGeometry{T}}=nothing, nscales::Integer=1) where {T<:Real,CT<:RealOrComplex{T}}","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.rigid_registration-Union{Tuple{CT}, Tuple{T}, Tuple{AbstractArray{CT, 3}, AbstractArray{CT, 3}, Union{Nothing, AbstractArray{T}}, RetrospectiveMotionCorrectionMRI.ParameterEstimationOptionsDiff}} where {T<:Real, CT<:Union{Complex{T}, T}}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.rigid_registration","text":"rigid_registration(u_moving, u_fixed, θ, options;\n                   spatial_geometry=nothing,\n                   nscales=1)\n\nPerforms the rigid registration of the 3D image u_moving with the fixed 3D image u_fixed. The user can input a rigid motion parameter θ (nothing in case no prior knowledge is available), and options via rigid_registration_options. In case the 3D image are associated to a specific spatial discretization, it can be specified with the keyword argument spatial_geometry. Multiscale acceleration can be specified with by setting the number of levels with the keyword nscales (in this case, each scaled subproblem solver runs options.niter iterations).\n\n\n\n\n\n","category":"method"},{"location":"functions/","page":"Main functions","title":"Main functions","text":"rigid_registration_options(; niter::Integer=10, verbose::Bool=false, fun_history::Bool=false)","category":"page"},{"location":"functions/#RetrospectiveMotionCorrectionMRI.rigid_registration_options-Tuple{}","page":"Main functions","title":"RetrospectiveMotionCorrectionMRI.rigid_registration_options","text":"rigid_registration_options(; niter=10, verbose=false, fun_history=false)\n\nReturns options for the rigid registration routine. niter sets the number of iterations, verbose=true can be used for debugging purposes, and fun_history=true allows the storage of the objective values at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"theory/#theory","page":"Rigid motion correction for MRI","title":"Motion correction for MRI","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"In this section, we briefly summarize the methodology that underpins reference-guided motion correction for MRI. The method is introduced and discussed in detail in [2].","category":"page"},{"location":"theory/#Fourier","page":"Rigid motion correction for MRI","title":"Motion-perturbed Fourier transform","text":"","category":"section"},{"location":"theory/#The-non-uniform-Fourier-transform","page":"Rigid motion correction for MRI","title":"The non-uniform Fourier transform","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"For a discretized (complex-valued) image mathbfu on some computational grid mathbfx_j_j, that is","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"mathbfu(mathbfx)=sum_j=1^nmathbfu_jdelta(mathbfx-mathbfx_j)","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"the (non-uniform) Fourier transform is defined as:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Fmathbfu(mathbfk)=sum_jmathbfu_jexp(2pimathrmimathbfkcdotmathbfx_j)qquadforallmathbfkin K","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"for some k-space subset K. For general k-space trajectories, this can be evaluated by non-uniform Fourier transform libraries such as FINUFFT.jl or NFFT.jl.","category":"page"},{"location":"theory/#Global-rigid-motion-under-the-Fourier-transform","page":"Rigid motion correction for MRI","title":"Global rigid motion under the Fourier transform","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Let's now assume that an image undergoes a rigid motion T(pmbtheta) parameterized by pmbthetainmathbbR^d (d=3 in 2D, and d=6 in 3D):","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"T(pmbtheta)(mathbfx)=R(pmbvarphi)mathbfx+pmbtauqquadmathrmwhere pmbtheta=(pmbvarphipmbtau)","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The parameter pmbtheta=(pmbvarphipmbtau) represents translation distances and rotation angles, respectively. The operator R(pmbvarphi) performs the coordinate rotations associated to the angles pmbvarphi.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The transformed image is mathbfu_T(pmbtheta)=mathbfucirc T(pmbtheta)^-1, and the perturbed Fourier transform of mathbfu can be defined as F(pmbtheta)mathbfu=Fmathbfu_T(pmbtheta). Thanks to elementary Fourier identities, this gives:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"F(pmbtheta)mathbfu(mathbfk)=exp(-2pimathrmimathbfkcdotpmbtau)Fmathbfu(R(pmbvarphi)^mathrmTmathbfk)","category":"page"},{"location":"theory/#Time-dependent-rigid-motion-under-the-Fourier-transform","page":"Rigid motion correction for MRI","title":"Time-dependent rigid motion under the Fourier transform","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"In MRI, the Fourier transform is evaluated in k-space according to a certain temporal sequence of wavenumbers K=mathbfk_t_t=1^n_t. For motion correction purposes, we must then postulate (in principle) as many rigid motion parameters pmbtheta_t as \"time\" steps.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"With a slight abuse of notation, we will now denote with pmbtheta the actual motion evolution pmbtheta_t_t=1^n_t, and consider as perturbed Fourier transform the following:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"F(pmbtheta)mathbfu=(F(pmbtheta_1)mathbfu(mathbfk_1)ldotsF(pmbtheta_n_t)mathbfu(mathbfk_n_t))","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Note that, in practice, we can assume that pmbtheta_t remains constant for time indexes associated to wavenumbers mathbfk_t that belongs to the same readout. In general, we can also assume that the rigid motion parameters vary smoothly in time.","category":"page"},{"location":"theory/#retromoco","page":"Rigid motion correction for MRI","title":"Alternating motion correction and reconstruction","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"A notable problem in MRI is motion corruption. We can assume that some data mathbfd has been acquired in k-space while the patient was moving inside the scanner. The conventional Fourier inverse transform of mathbfd will produce a corrupted image mathbfu, and won't be suitable for radiological assessment.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Retrospective rigid motion correction tries to estimate the motion parameter pmbtheta together with a motion-clean image mathbfu such that the motion artifacts are no longer present. Mathematically, it is equivalent to the bi-level minimization problem:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"min_mathbfupmbthetaJ(mathbfupmbtheta)=dfrac12F(pmbtheta)mathbfu-mathbfd^2+g_u(mathbfu)+g_theta(pmbtheta)","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"for some regularization terms g_u and g_theta.","category":"page"},{"location":"theory/#Solution-method","page":"Rigid motion correction for MRI","title":"Solution method","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The optimization problem is solved by alternating update of the unknowns mathbfu and pmbtheta. The two subproblems are associated to:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"image reconstruction: min_mathbfuJ(mathbfupmbtheta)\nmotion parameter estimation: min_pmbthetaJ(mathbfupmbtheta).","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"More details are expounded in the respective sections.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"We offer the convenience function motion_correction_options to set the overall options of this alternating scheme. The suboptions image_reconstruction_options and parameter_estimation_options for each specific step are set by dedicated option routines described in their respective section. The alternating solver is called with the function motion_corrected_reconstruction.","category":"page"},{"location":"theory/#imrecon","page":"Rigid motion correction for MRI","title":"Image reconstruction","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"In this section, we describe the optimization problem related to image reconstruction, given a known rigid motion parameter.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The minimization problem is:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"min_mathbfuJ(mathbfu)=dfrac12F(pmbtheta)mathbfu-mathbfd^2+g(mathbfu)","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The linear operator F(pmbtheta) is the motion-perturbed Fourier transform (described here), pmbtheta a fixed rigid motion state, and mathbfd some given data.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The regularization term g is typically a variant of total variation, and is handled through the package FastSolversForWeightedTV. For more details on how to set this regularization term consult the documentation in FastSolversForWeightedTV and the convenience function image_reconstruction_options.","category":"page"},{"location":"theory/#Solution-method-2","page":"Rigid motion correction for MRI","title":"Solution method","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"In order to solve the non-smooth convex optimization problem, we focus on the FISTA method (see 3). For a generic optimization problem of the form min_mathbfxf(mathbfx)+g(mathbfx), it results in the iterative scheme:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"beginaligned\ntildemathbfx_k+1=mathrmprox_1Lg(mathbfx_k-nabla_mathbfx_kfL)\nt_k+1=dfrac1+sqrt1+4t_k^22\nmathbfx_k+1=tildemathbfx_k+1+dfract_k-1t_k+1(tildemathbfx_k+1-tildemathbfx_k)\nendaligned","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Here, mathrmprox represents the proximal operator, L is the Lipschitz constant of nabla f, and t_k are the momentum factors associated to Nesterov acceleration (t_0=1). Despite the theoretical analysis, it is reported in the literature that it may be beneficial to reset the Nesterov momentum to 1 after a certain number of iterations to avoid convergence stagnation.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"A special note must be dedicated to the choice of L. For image reconstruction f corresponds to the function J. It can be easily seen that the Lipschitz constant for nabla J is the spectral radius of F(pmbtheta). Due to the fact that the unknowns pmbtheta will be updated frequently, this constant must be computed every time such an update occurs and cannot be optimally set for any choice of pmbtheta. The option routine image_reconstruction_options additionally offers the option to estimate the Lipschitz constant via the power method with the keyword niter_estimate_Lipschitz, which must be set to a certain integer value equal to the number of iterations the power method is run.","category":"page"},{"location":"theory/#parest","page":"Rigid motion correction for MRI","title":"Rigid motion parameter estimation","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"In this section, we lay out a detailed formulation of the optimization problem related to motion parameter estimation, given a known image. This is, essentially, a generalized rigid registration routine.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The mathematical problem considered is:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"min_pmbthetaJ(pmbtheta)=dfrac12F(pmbtheta)mathbfu-mathbfd^2+dfraclambda^22Dpmbtheta^2","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The linear operator F(pmbtheta) is the motion-perturbed Fourier transform (described here), mathbfu a fixed image, and mathbfd some given data.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The regularization term is typically aimed at enforcing temporal smoothness. Its strength is regulated by the weight lambda and regularization operator D (e.g. a time-derivative operator).","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Temporal smoothness regularization can be integrated or replaced by hard constraints. It is convenient, for example, to define an time-wise interpolation operator I that transforms coarse-grid arrays tildepmbtheta to fine-grid arrays tildepmbtheta. In this case, we solve the problem","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"min_tildepmbthetaJ(tildepmbtheta)=dfrac12F(Itildepmbtheta)mathbfu-mathbfd^2+dfraclambda^22Dtildepmbtheta^2","category":"page"},{"location":"theory/#Solution-method-3","page":"Rigid motion correction for MRI","title":"Solution method","text":"","category":"section"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"We implemented a rather conventional pseudo-Hessian method for the optimization problem:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"pmbthetaleftarrowpmbtheta-mathrmsteplength*B^-1nabla_pmbthetaJ","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"All the parameters described in this section can be set via the routine parameter_estimation_options. Typically mathrmsteplength=1.","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"The pseudo-Hessian B is based on the Gauss-Newton approximation of the analytical Hessian nabla_pmbtheta^2J. Note, however that nabla_pmbtheta^2J is ill-conditioned for the wavenumber mathbfk=0 and high-frequency wavenumbers. Therefore, we use the Levenberg-Marquardt regularization:","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"tildeB=B+mathrmscaling_mathrmdiag*mathrmdiag(B)+mathrmscaling_mathrmmean*mathrmmean(mathrmdiag(B))otimesmathrmId+mathrmscaling_mathrmid*mathrmId","category":"page"},{"location":"theory/","page":"Rigid motion correction for MRI","title":"Rigid motion correction for MRI","text":"Here, the mathrmmean is performed for the diagonal elements of each rigid-motion parameter. Typically, mathrmscaling_mathrmid=0, mathrmscaling_mathrmmean=mathrm1e-1*mathrmscaling_mathrmdiag and mathrmscaling_mathrmdiag is a relatively small number.","category":"page"},{"location":"examples/#examples","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"In this section, we present a brief step-by-step tutorial on how to perform motion correction for MRI using the tools provided by RetrospectiveMotionCorrectionMRI.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Make sure to have installed the package RetrospectiveMotionCorrectionMRI and its dependency by following the instructions highlighted here. For plotting, we are also going to make use of PyPlot, to install it press ] in the Julia REPL and type:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"(@v1.8) pkg> add PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Let's start by loading all the needed modules:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"using RetrospectiveMotionCorrectionMRI, FastSolversForWeightedTV, UtilitiesForMRI, AbstractProximableFunctions, LinearAlgebra, PyPlot","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We can define a simple spatial discretization X and k-space trajectory K (in this case, corresponding to Cartesian dense sampling). The associated Fourier transform will be F:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Spatial geometry\nfov = (1f0, 2f0, 2f0)\nn = (64, 64, 64)\no = (0.5f0, 1f0, 1f0)\nX = spatial_geometry(fov, n; origin=o)\n\n# k-space trajectory (Cartesian dense sampling)\nphase_encoding = (1, 2)\nK = kspace_sampling(X, phase_encoding)\nnt, nk = size(K)\n\n# Fourier operator\nF = nfft_linop(X, K)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"We are going now to define a simple 3D image and some rigid motion parameter evolution, which corresponds to a step function in time (e.g. the object moves once halfway through the acquisition). The motion-corrupted data is obtained by perturbing the conventional Fourier transform:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Setting image ground-truth (= not motion corrupted)\nground_truth = zeros(ComplexF32, n)\nground_truth[33-10:33+10, 33-10:33+10, 33-10:33+10] .= 1\n\n# Setting simple rigid motion parameters\nnt, _ = size(K)\nθ_true = zeros(Float32, nt, 6)\nθ_true[div(nt,2)+51:end,:] .= reshape([0.0f0, 0.0f0, 0.0f0, Float32(pi)/180*10, 0f0, 0f0], 1, 6)\n\n# Motion-corrupted data\nd = F(θ_true)*ground_truth","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To perform motion correction we need to define several options related to the alternating minimization scheme described in this methodological section. Refer to that section for in-depth discussion of each of these options:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Optimization options:\n    ## Image reconstruction options\n    h = spacing(X); L = 4f0*sum(1 ./h.^2)\n    opt_inner = FISTA_options(L; Nesterov=true, niter=10)\n    # η = 1f-2*structural_mean(ground_truth)   # reference guide\n    # P = structural_weight(ground_truth; η=η) # reference guide\n    P = nothing                                # no reference\n    g = gradient_norm(2, 1, size(ground_truth), h; complex=true, weight=P, options=opt_inner)\n    ε = 0.8f0*g(ground_truth)\n    opt_imrecon = image_reconstruction_options(; prox=indicator(g ≤ ε), Nesterov=true, niter=5, niter_estimate_Lipschitz=3, verbose=true, fun_history=true)\n\n    ## Parameter estimation options\n    ti = Float32.(range(1, nt; length=16))\n    t = Float32.(1:nt)\n    Ip = interpolation1d_motionpars_linop(ti, t)\n    D = derivative1d_motionpars_linop(t, 2; pars=(true, true, true, true, true, true))/4f0\n    opt_parest = parameter_estimation_options(; niter=5, steplength=1f0, λ=0f0, scaling_diagonal=1f-3, scaling_mean=1f-4, scaling_id=0f0, reg_matrix=D, interp_matrix=Ip, verbose=true, fun_history=true)\n\n    ## Overall options\n    options = motion_correction_options(; image_reconstruction_options=opt_imrecon, parameter_estimation_options=opt_parest, niter=40, verbose=true, fun_history=true)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Notably, we can opt to perform motion correction with or without a reference guide. This specific behavior is determined by the weight linear operator P (comment/uncomment the corresponding line to study the effect on the final results).","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"The conventional reconstruction is simply performed by:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Conventional reconstruction\nu_conventional = F'*d","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"The results will be highly corrupted.","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"To run motion correction:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Motion-corrected reconstruction\nθ0 = zeros(Float32, length(ti), 6)\nu0 = zeros(ComplexF32, n)\nu, θ = motion_corrected_reconstruction(F, d, u0, θ0, options)\nθ = reshape(Ip*vec(θ), length(t), 6)","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"Finally, we can compare the results by:","category":"page"},{"location":"examples/","page":"Getting started","title":"Getting started","text":"# Plotting\n    ## Image\n    figure()\n    x, y, _ = coord(X)\n    extent = (x[1], x[end], y[1], y[end])\n    vmin = -0.1; vmax = 1.1\n    subplot(1, 3, 1)\n    imshow(abs.(u_conventional[:, end:-1:1, 33])'; vmin=vmin, vmax=vmax, extent=extent)\n    title(\"Conventional\")\n    subplot(1, 3, 2)\n    imshow(abs.(u[:, end:-1:1, 33])'; vmin=vmin, vmax=vmax, extent=extent)\n    title(\"Corrected\")\n    subplot(1, 3, 3)\n    imshow(abs.(ground_truth[:, end:-1:1, 33])'; vmin=vmin, vmax=vmax, extent=extent)\n    title(\"Ground-truth\")\n\n    ## Motion parameters\n    figure()\n    plot(θ[:, 4])\n    plot(θ_true[:, 4])","category":"page"},{"location":"installation/#install","page":"Installation","title":"Installation instructions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the Julia REPL, simply type ] and","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(@v1.8) pkg> add https://github.com/grizzuti/AbstractLinearOperators.git\n(@v1.8) pkg> add https://github.com/grizzuti/AbstractProximableFunctions.git\n(@v1.8) pkg> add https://github.com/grizzuti/FastSolversForWeightedTV.git\n(@v1.8) pkg> add https://github.com/grizzuti/UtilitiesForMRI.git\n(@v1.8) pkg> add https://github.com/grizzuti/RetrospectiveMotionCorrectionMRI.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The packages AbstractLinearOperators, AbstractProximableFunctions, FastSolversForWeightedTV, and UtilitiesForMRI have to be explicitly installed since they are unregistered at the moment.","category":"page"},{"location":"#intro","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package implements the algorithmic tools to perform retrospective motion correction for MRI based on a reference-guided TV regularization (see [2]). It combines several custom packages, the most important building blocks are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FastSolversForWeightedTV: for the computation of proximal/projection operators \nUtilitiesForMRI: for the computation and differentiation of the non-uniform Fourier transform with respect to rigid-body motion perturbation.","category":"page"},{"location":"#references","page":"Introduction","title":"Related publications","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Ehrhardt, M. J., and Betcke, M. M., (2015). Multi-Contrast MRI Reconstruction with Structure-Guided Total Variation (https://arxiv.org/abs/1511.06631), SIAM J. IMAGING SCIENCES, 9(3), 1084-1106, doi:10.1137/15M1047325\nRizzuti, G., Sbrizzi, A., and van Leeuwen, T., (2022). Joint Retrospective Motion Correction and Reconstruction for Brain MRI With a Reference Contrast, IEEE Transaction on Computational Imaging, 8, 490-504, doi:10.1109/TCI.2022.3183383\nBeck, A., and Teboulle, M., (2009). A Fast Iterative Shrinkage-Thresholding Algorithm for Linear Inverse Problems, SIAM Journal on Imaging Sciences, 2(1), 183-202, doi:10.1137/080716542","category":"page"}]
}
