<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rigid motion correction for MRI · RetrospectiveMotionCorrectionMRI.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RetrospectiveMotionCorrectionMRI.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li class="is-active"><a class="tocitem" href>Rigid motion correction for MRI</a><ul class="internal"><li><a class="tocitem" href="#Fourier"><span>Motion-perturbed Fourier transform</span></a></li><li><a class="tocitem" href="#retromoco"><span>Alternating motion correction and reconstruction</span></a></li><li><a class="tocitem" href="#imrecon"><span>Image reconstruction</span></a></li><li><a class="tocitem" href="#parest"><span>Rigid motion parameter estimation</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Getting started</a></li><li><a class="tocitem" href="../functions/">Main functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Rigid motion correction for MRI</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Rigid motion correction for MRI</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/grizzuti/RetrospectiveMotionCorrectionMRI/blob/main/docs/src/theory.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="theory"><a class="docs-heading-anchor" href="#theory">Motion correction for MRI</a><a id="theory-1"></a><a class="docs-heading-anchor-permalink" href="#theory" title="Permalink"></a></h1><p>In this section, we briefly summarize the methodology that underpins reference-guided motion correction for MRI. The method is introduced and discussed in detail in <a href="../#references">[2]</a>.</p><h2 id="Fourier"><a class="docs-heading-anchor" href="#Fourier">Motion-perturbed Fourier transform</a><a id="Fourier-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier" title="Permalink"></a></h2><h3 id="The-non-uniform-Fourier-transform"><a class="docs-heading-anchor" href="#The-non-uniform-Fourier-transform">The non-uniform Fourier transform</a><a id="The-non-uniform-Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#The-non-uniform-Fourier-transform" title="Permalink"></a></h3><p>For a discretized (complex-valued) image <span>$\mathbf{u}$</span> on some computational grid <span>$\{\mathbf{x}_j\}_j$</span>, that is</p><p class="math-container">\[\mathbf{u}(\mathbf{x})=\sum_{j=1}^n\mathbf{u}_j\delta(\mathbf{x}-\mathbf{x}_j),\]</p><p>the (non-uniform) Fourier transform is defined as:</p><p class="math-container">\[F\mathbf{u}\,(\mathbf{k})=\sum_j\mathbf{u}_j\exp{(2\pi\mathrm{i}\,\mathbf{k}\cdot\mathbf{x}_j)},\qquad\forall\,\mathbf{k}\in K\]</p><p>for some <span>$k$</span>-space subset <span>$K$</span>. For general <span>$k$</span>-space trajectories, this can be evaluated by non-uniform Fourier transform libraries such as <a href="https://github.com/ludvigak/FINUFFT.jl"><code>FINUFFT.jl</code></a> or <a href="https://github.com/JuliaMath/NFFT.jl"><code>NFFT.jl</code></a>.</p><h3 id="Global-rigid-motion-under-the-Fourier-transform"><a class="docs-heading-anchor" href="#Global-rigid-motion-under-the-Fourier-transform">Global rigid motion under the Fourier transform</a><a id="Global-rigid-motion-under-the-Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Global-rigid-motion-under-the-Fourier-transform" title="Permalink"></a></h3><p>Let&#39;s now assume that an image undergoes a rigid motion <span>$T(\pmb{\theta})$</span> parameterized by <span>$\pmb{\theta}\in\mathbb{R}^d$</span> (<span>$d=3$</span> in 2D, and <span>$d=6$</span> in 3D):</p><p class="math-container">\[T(\pmb{\theta})(\mathbf{x})=R(\pmb{\varphi})\mathbf{x}+\pmb{\tau},\qquad\mathrm{where\ }\pmb{\theta}=(\pmb{\varphi},\pmb{\tau}).\]</p><p>The parameter <span>$\pmb{\theta}=(\pmb{\varphi},\pmb{\tau})$</span> represents translation distances and rotation angles, respectively. The operator <span>$R(\pmb{\varphi})$</span> performs the coordinate rotations associated to the angles <span>$\pmb{\varphi}$</span>.</p><p>The transformed image is <span>$\mathbf{u}_{T(\pmb{\theta})}=\mathbf{u}\circ T(\pmb{\theta})^{-1}$</span>, and the <em>perturbed</em> Fourier transform of <span>$\mathbf{u}$</span> can be defined as <span>$F(\pmb{\theta})\mathbf{u}:=F\mathbf{u}_{T(\pmb{\theta})}$</span>. Thanks to elementary Fourier identities, this gives:</p><p class="math-container">\[F(\pmb{\theta})\mathbf{u}\,(\mathbf{k})=\exp{(-2\pi\mathrm{i}\,\mathbf{k}\cdot\pmb{\tau})}F\mathbf{u}\,(R(\pmb{\varphi})^{\mathrm{T}}\mathbf{k}).\]</p><h3 id="Time-dependent-rigid-motion-under-the-Fourier-transform"><a class="docs-heading-anchor" href="#Time-dependent-rigid-motion-under-the-Fourier-transform">Time-dependent rigid motion under the Fourier transform</a><a id="Time-dependent-rigid-motion-under-the-Fourier-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-rigid-motion-under-the-Fourier-transform" title="Permalink"></a></h3><p>In MRI, the Fourier transform is evaluated in <span>$k$</span>-space according to a certain temporal sequence of wavenumbers <span>$K=\{\mathbf{k}_t\}_{t=1}^{n_t}$</span>. For motion correction purposes, we must then postulate (in principle) as many rigid motion parameters <span>$\pmb{\theta}_t$</span> as &quot;time&quot; steps.</p><p>With a slight abuse of notation, we will now denote with <span>$\pmb{\theta}$</span> the actual motion evolution <span>$\{\pmb{\theta}_t\}_{t=1}^{n_t}$</span>, and consider as perturbed Fourier transform the following:</p><p class="math-container">\[F(\pmb{\theta})\mathbf{u}:=(F(\pmb{\theta}_1)\mathbf{u}(\mathbf{k}_1),\ldots,F(\pmb{\theta}_{n_t})\mathbf{u}(\mathbf{k}_{n_t})).\]</p><p>Note that, in practice, we can assume that <span>$\pmb{\theta}_t$</span> remains constant for time indexes associated to wavenumbers <span>$\mathbf{k}_t$</span> that belongs to the same readout. In general, we can also assume that the rigid motion parameters vary smoothly in time.</p><h2 id="retromoco"><a class="docs-heading-anchor" href="#retromoco">Alternating motion correction and reconstruction</a><a id="retromoco-1"></a><a class="docs-heading-anchor-permalink" href="#retromoco" title="Permalink"></a></h2><p>A notable problem in MRI is motion corruption. We can assume that some data <span>$\mathbf{d}$</span> has been acquired in <span>$k$</span>-space while the patient was moving inside the scanner. The conventional Fourier inverse transform of <span>$\mathbf{d}$</span> will produce a corrupted image <span>$\mathbf{u}$</span>, and won&#39;t be suitable for radiological assessment.</p><p>Retrospective rigid motion correction tries to estimate the motion parameter <span>$\pmb{\theta}$</span> together with a motion-clean image <span>$\mathbf{u}$</span> such that the motion artifacts are no longer present. Mathematically, it is equivalent to the bi-level minimization problem:</p><p class="math-container">\[\min_{\mathbf{u},\pmb{\theta}}J(\mathbf{u},\pmb{\theta})=\dfrac{1}{2}||F(\pmb{\theta})\mathbf{u}-\mathbf{d}||^2+g_u(\mathbf{u})+g_{\theta}(\pmb{\theta}),\]</p><p>for some regularization terms <span>$g_u$</span> and <span>$g_{\theta}$</span>.</p><h3 id="Solution-method"><a class="docs-heading-anchor" href="#Solution-method">Solution method</a><a id="Solution-method-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-method" title="Permalink"></a></h3><p>The optimization problem is solved by alternating update of the unknowns <span>$\mathbf{u}$</span> and <span>$\pmb{\theta}$</span>. The two subproblems are associated to:</p><ul><li><a href="#imrecon">image reconstruction</a>: <span>$\min_{\mathbf{u}}J(\mathbf{u},\pmb{\theta})$</span></li><li><a href="#parest">motion parameter estimation</a>: <span>$\min_{\pmb{\theta}}J(\mathbf{u},\pmb{\theta})$</span>.</li></ul><p>More details are expounded in the respective sections.</p><p>We offer the convenience function <a href="../functions/#RetrospectiveMotionCorrectionMRI.motion_correction_options-Tuple{}"><code>motion_correction_options</code></a> to set the overall options of this alternating scheme. The suboptions <a href="../functions/#RetrospectiveMotionCorrectionMRI.image_reconstruction_options-Tuple{}"><code>image_reconstruction_options</code></a> and <a href="../functions/#RetrospectiveMotionCorrectionMRI.parameter_estimation_options-Tuple{}"><code>parameter_estimation_options</code></a> for each specific step are set by dedicated option routines described in their respective section. The alternating solver is called with the function <a href="../functions/#RetrospectiveMotionCorrectionMRI.motion_corrected_reconstruction-Union{Tuple{CT}, Tuple{T}, Tuple{StructuredNFFTtype2LinOp{T}, AbstractMatrix{CT}, AbstractArray{CT, 3}, AbstractMatrix{T}, RetrospectiveMotionCorrectionMRI.MotionCorrectionOptionsAlternatingFISTADiff}} where {T&lt;:Real, CT&lt;:Union{Complex{T}, T}}"><code>motion_corrected_reconstruction</code></a>.</p><h2 id="imrecon"><a class="docs-heading-anchor" href="#imrecon">Image reconstruction</a><a id="imrecon-1"></a><a class="docs-heading-anchor-permalink" href="#imrecon" title="Permalink"></a></h2><p>In this section, we describe the optimization problem related to image reconstruction, given a <em>known</em> rigid motion parameter.</p><p>The minimization problem is:</p><p class="math-container">\[\min_{\mathbf{u}}J(\mathbf{u})=\dfrac{1}{2}||F(\pmb{\theta})\mathbf{u}-\mathbf{d}||^2+g(\mathbf{u}).\]</p><p>The linear operator <span>$F(\pmb{\theta})$</span> is the motion-perturbed Fourier transform (described <a href="#Fourier">here</a>), <span>$\pmb{\theta}$</span> a fixed rigid motion state, and <span>$\mathbf{d}$</span> some given data.</p><p>The regularization term <span>$g$</span> is typically a variant of total variation, and is handled through the package <code>FastSolversForWeightedTV</code>. For more details on how to set this regularization term consult the documentation in <code>FastSolversForWeightedTV</code> and the convenience function <a href="../functions/#RetrospectiveMotionCorrectionMRI.image_reconstruction_options-Tuple{}"><code>image_reconstruction_options</code></a>.</p><h3 id="Solution-method-2"><a class="docs-heading-anchor" href="#Solution-method-2">Solution method</a><a class="docs-heading-anchor-permalink" href="#Solution-method-2" title="Permalink"></a></h3><p>In order to solve the non-smooth convex optimization problem, we focus on the FISTA method (see <a href="../#references">3</a>). For a generic optimization problem of the form <span>$\min_{\mathbf{x}}f(\mathbf{x})+g(\mathbf{x})$</span>, it results in the iterative scheme:</p><p class="math-container">\[\begin{aligned}
\tilde{\mathbf{x}}_{k+1}&amp;=\mathrm{prox}_{1/L,g}(\mathbf{x}_k-\nabla_{\mathbf{x}_k}f/L),\\
t_{k+1}&amp;=\dfrac{1+\sqrt{1+4t_k^2}}{2},\\
\mathbf{x}_{k+1}&amp;=\tilde{\mathbf{x}}_{k+1}+\dfrac{t_k-1}{t_{k+1}}(\tilde{\mathbf{x}}_{k+1}-\tilde{\mathbf{x}}_k).
\end{aligned}\]</p><p>Here, <span>$\mathrm{prox}$</span> represents the proximal operator, <span>$L$</span> is the Lipschitz constant of <span>$\nabla f$</span>, and <span>$t_k$</span> are the momentum factors associated to Nesterov acceleration (<span>$t_0=1$</span>). Despite the theoretical analysis, it is reported in the literature that it may be beneficial to reset the Nesterov momentum to <span>$1$</span> after a certain number of iterations to avoid convergence stagnation.</p><p>A special note must be dedicated to the choice of <span>$L$</span>. For image reconstruction <span>$f$</span> corresponds to the function <span>$J$</span>. It can be easily seen that the Lipschitz constant for <span>$\nabla J$</span> is the spectral radius of <span>$F(\pmb{\theta})$</span>. Due to the fact that the unknowns <span>$\pmb{\theta}$</span> will be updated frequently, this constant must be computed every time such an update occurs and cannot be optimally set for any choice of <span>$\pmb{\theta}$</span>. The option routine <a href="../functions/#RetrospectiveMotionCorrectionMRI.image_reconstruction_options-Tuple{}"><code>image_reconstruction_options</code></a> additionally offers the option to estimate the Lipschitz constant via the power method with the keyword <code>niter_estimate_Lipschitz</code>, which must be set to a certain integer value equal to the number of iterations the power method is run.</p><h2 id="parest"><a class="docs-heading-anchor" href="#parest">Rigid motion parameter estimation</a><a id="parest-1"></a><a class="docs-heading-anchor-permalink" href="#parest" title="Permalink"></a></h2><p>In this section, we lay out a detailed formulation of the optimization problem related to motion parameter estimation, given a <em>known</em> image. This is, essentially, a generalized rigid registration routine.</p><p>The mathematical problem considered is:</p><p class="math-container">\[\min_{\pmb{\theta}}J(\pmb{\theta})=\dfrac{1}{2}||F(\pmb{\theta})\mathbf{u}-\mathbf{d}||^2+\dfrac{\lambda^2}{2}||D\pmb{\theta}||^2.\]</p><p>The linear operator <span>$F(\pmb{\theta})$</span> is the motion-perturbed Fourier transform (described <a href="#Fourier">here</a>), <span>$\mathbf{u}$</span> a fixed image, and <span>$\mathbf{d}$</span> some given data.</p><p>The regularization term is typically aimed at enforcing temporal smoothness. Its strength is regulated by the weight <span>$\lambda$</span> and regularization operator <span>$D$</span> (e.g. a time-derivative operator).</p><p>Temporal smoothness regularization can be integrated or replaced by hard constraints. It is convenient, for example, to define an time-wise interpolation operator <span>$I$</span> that transforms coarse-grid arrays <span>$\tilde{\pmb{\theta}}$</span> to fine-grid arrays <span>$\tilde{\pmb{\theta}}$</span>. In this case, we solve the problem</p><p class="math-container">\[\min_{\tilde{\pmb{\theta}}}J(\tilde{\pmb{\theta}})=\dfrac{1}{2}||F(I\tilde{\pmb{\theta}})\mathbf{u}-\mathbf{d}||^2+\dfrac{\lambda^2}{2}||D\tilde{\pmb{\theta}}||^2.\]</p><h3 id="Solution-method-3"><a class="docs-heading-anchor" href="#Solution-method-3">Solution method</a><a class="docs-heading-anchor-permalink" href="#Solution-method-3" title="Permalink"></a></h3><p>We implemented a rather conventional pseudo-Hessian method for the optimization problem:</p><p class="math-container">\[\pmb{\theta}\leftarrow\pmb{\theta}-\mathrm{steplength}*B^{-1}\nabla_{\pmb{\theta}}J.\]</p><p>All the parameters described in this section can be set via the routine <a href="../functions/#RetrospectiveMotionCorrectionMRI.parameter_estimation_options-Tuple{}"><code>parameter_estimation_options</code></a>. Typically <span>$\mathrm{steplength}=1$</span>.</p><p>The pseudo-Hessian <span>$B$</span> is based on the Gauss-Newton approximation of the analytical Hessian <span>$\nabla_{\pmb{\theta}}^2J$</span>. Note, however that <span>$\nabla_{\pmb{\theta}}^2J$</span> is ill-conditioned for the wavenumber <span>$\mathbf{k}=0$</span> and high-frequency wavenumbers. Therefore, we use the Levenberg-Marquardt regularization:</p><p class="math-container">\[\tilde{B}=B+\mathrm{scaling}_{\mathrm{diag}}*\mathrm{diag}(B)+\mathrm{scaling}_{\mathrm{mean}}*\mathrm{mean}(\mathrm{diag}(B))\otimes\mathrm{Id}+\mathrm{scaling}_{\mathrm{id}}*\mathrm{Id}.\]</p><p>Here, the <span>$\mathrm{mean}$</span> is performed for the diagonal elements of each rigid-motion parameter. Typically, <span>$\mathrm{scaling}_{\mathrm{id}}=0$</span>, <span>$\mathrm{scaling}_{\mathrm{mean}}=\mathrm{1e-1}*\mathrm{scaling}_{\mathrm{diag}}$</span> and <span>$\mathrm{scaling}_{\mathrm{diag}}$</span> is a relatively small number.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">« Installation</a><a class="docs-footer-nextpage" href="../examples/">Getting started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 8 March 2023 12:15">Wednesday 8 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
